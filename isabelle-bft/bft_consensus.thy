theory bft_consensus
  imports system_model
begin

text \<open>We now define what it means for an algorithm to solve the consensus problem:

Safety: It sends the same message to all clients,
the message must have been proposed by one client.

Final Check:
All clients who sent a request to a non-faulty node got a response.

Lifeness: Once all internal messages from non-faulty nodes have been processed and there was 
at least one client message proposal to a non-faulty node, then the final check should hold.
Moreover, there is a maximum of messages generated by non-faulty nodes.

Together these conditions ensure liveness, without having to talk about infinite executions.
\<close>

definition
\<open>all_client_responses S \<equiv> filter (\<lambda>a. client_action_kind a = Out) (trace S)\<close>

definition
\<open>all_client_requests S \<equiv> filter (\<lambda>a. client_action_kind a = In) (trace S)\<close>


definition 
\<open>safety_same_response S \<equiv> 
  \<exists>req\<in>set (all_client_requests S). 
    \<forall>resp \<in> set (all_client_responses S). 
      client_action_node resp \<notin> failed_nodes S \<longrightarrow>  
        client_action_message req = client_action_message resp\<close>

definition
\<open>final_check S \<equiv>
  \<forall>req\<in>set (all_client_requests S). 
    client_action_node req \<notin> failed_nodes S \<longrightarrow> (
    \<exists>resp \<in> set (all_client_responses S).
     client_action_client resp = client_action_client req) 
\<close>

